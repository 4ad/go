Edit ,d
git diff origin/master..HEAD |wc
git push -f 4ad sparc64
go install -v cmd/asm cmd/link
go install -v cmd/compile
go install -v debug... cmd/cgo
go install -v cmd/vet
GOOS=solaris GOARCH=sparc64 go install -a -gcflags="-e" -v runtime
CC=sparcv9-solaris2.12-gcc GO_EXTLINK_ENABLED=1 CGO_ENABLED=1 GOOS=solaris GOARCH=sparc64 go install -v runtime/cgo
GOOS=solaris GOARCH=sparc64 go build -a -gcflags="-S" -asmflags="-S" runtime 2>/tmp/runtime.s
cd cmd/link/internal/sparc64
cd cmd/link/internal/ld
cd cmd/compile/internal/sparc64
cd cmd/compile/internal/gc
GOARCH=sparc64 GOOS=solaris go vet runtime
cd alt && mk clean && mk bigmov.go.ext
cd new && mk clean && mk helloworld.out.s
scp helloworld.out daffodil:

reserve R6

!!!
NO DYNAMIC SIZED INSTRUCTIONS
!!!

Stack management
RET
Auto/param references.

Check resvd.
!ASMULL
!AUMULL
	-> AMULD
*ASMULH
*AUMULH

!AHINT -> ARNOP

!ASDIV ->? ASDIVD
!AUDIV ->? AUDIVD
!AMUL -> AMULD

!ALSL -> ASLL
!ALSR -> ASRL
!AASR -> ASRA

(Go) CMP operand order is like arm64, this translates to *reverse* order in native assembly.

!AFCVTZSD -> AFDTOX
!AFCVTZSS -> AFSTOX
!AFCVTZSDW -> AFDTOI
!AFCVTZSSW -> AFSTOI
	what about float -> unsigned?

!AFCVTSD -> AFSTOD
!AFCVTDS -> AFDTOS

!ASCVTFD -> AFXTOD
!ASCVTFS -> AFXTOS
!ASCVTFWD -> AFITOD
!ASCVTFWS -> AFITOS
	what about unsigned -> float?

===

0(FP), first argument
8(FP), 2nd argument

[-frame, 0)(SP), automatics

// automatic N at -(8+8N)(BFP)
// incoming argument N at (176+8N)(BFP)
// outgoing argument N at (176+8N)(BSP)

==
!sparc64.BIG
for small integer multiplication, maybe we need conversion to clear high bits

==

OLT for TFLOAT

==

Check Prog.Reg

==

Optimize duffcopy

==

Why not CAS retry?

==

Runnable tests
235.go: print all numbers with 2, 3, or 5 as factor using channels, needs goroutine and channels
64bit.go: test 64-bit arithmetic, runoutput test, needs basic runtime and os.Exit
alias1.go: Test that dynamic interface checks treat byte=uint8 and rune=int or rune=int32.
append.go: Semi-exhaustive test for the append predeclared function. Needs fmt and reflect.
args.go: test os.Args. Needs os and panic.
bigalg.go: Test the internal "algorithms" for objects larger than a word: hashing, equality etc. Needs map, goroutine, panic, etc.
bigmap.go: Internally a map holds elements in up to 255 bytes of key+value. When key or value or both are too large, it uses pointers to key+value instead.  Test all the combinations. Needs map, make. panic.
blank.go: Test behavior of the blank identifier (_). Needs interface conversion, panic and unsafe.
bom.go: check that source code with BOM are accpeted. runoutput test.
chancap.go: Test the cap predeclared function applied to channels. Needs channel.
chanlinear.go: Test that dequeueing from a pending channel doesn't take linear time. (WRONG COMMENT?). Needs channel, fmt, time.
char_lit.go: Test character literal syntax. Needs basic runtime and os.Exit.
clearfat.go: Check that {5,6,8,9}g/ggen.c:clearfat is zeroing the entire object. runoutput test.
closedchan.go: Test close(c), receive of closed channel.
closure.go: Test the behavior of closures. Needs channel and runtime.ReadMemStats.
// not ordered alphabetically from now on
func.go: Test simple functions. Needs only basic runtime.
func5.go: Test functions and goroutines. Needs goroutine and channels.
func6.go: Test closures in if conditions.
func7.go: Test evaluation order in if condition.
func8.go: Test evaluation order. Needs basic runtime and string concat.
const.go: Test simple boolean and numeric constants. Needs basic runtime and os.Getenv.
const3.go: Test typed integer constants. Needs fmt.
const4.go: Test len constants and non-constants, http://golang.org/issue/3244. Needs channel.
convert.go: Test types of constant expressions, using reflect. Needs reflect.
divide.go: Test divide corner cases. (e.g. int64(-1<<63)/int64(-1)).
divmod.go: Test division of variables. Generate many test casesâ€¦.. Primarily useful for testing software div/mod. Needs defer/recover, but otherwise just basic runtime.
intcvt.go: Test implicit and explicit conversions of constants.
method.go: Test simple methods of various types, with pointer and value receivers. Needs defer/recover.


Compile only tests
// not ordered alphabetically from now on
func2.go: Test function signatures.


Errchk tests: portable
alias.go: Test that error messages say what the source file says (uint8 vs byte, int32 vs. rune).
assign.go: Verify simple assignment errors are caught by the compiler.
assign1.go: Verify assignment rules are enforced by the compiler.
blank1.go: Test that incorrect uses of the blank identifier are caught.
bombad.go: Test that BOM anywhere but at the file start is an error.
bounds.go: Test using compiler diagnostic flags, that bounds check elimination is eliminating the correct checks.
char_lit1.go: Verify that illegal character literals are detected.
// not ordered alphabetically from now on
func1.go: Test that result parameters are in the same scope as regular parameters.
func3.go: Verify that illegal function signatures are detected.
func4.go: Verify that it is illegal to take the address of a function.
funcdup.go: (Test duplicated argument names)
funcdup2.go: (Test input/output arguments with the same name)
const1.go: Verify overflow is detected when using numeric constants.
const2.go: Verify that large integer constant expressions cause overflow.
const5.go: Test that len non-constants are not constants, http://golang.org/issue/3244.
const6.go: Ideal vs non-ideal bool. See issue 3915, 3923. 
cmp6.go: Verify that incorrect comparisons are detected.
cmplx.go: Verify that incorrect invocations of the complex predeclared function are detected.
