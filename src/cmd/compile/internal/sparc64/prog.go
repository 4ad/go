// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package sparc64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/sparc64"
)

const (
	LeftRdwr  uint32 = gc.LeftRead | gc.LeftWrite
	RightRdwr uint32 = gc.RightRead | gc.RightWrite
)

// This table gives the basic information about instruction
// generated by the compiler and processed in the optimizer.
// See opt.h for bit definitions.
//
// Instructions not generated need not be listed.
// As an exception to that rule, we typically write down all the
// size variants of an operation even if we just use a subset.
//
// The table is formatted for 8-space tabs.
var progtable = [sparc64.ALAST]obj.ProgInfo{
	obj.ATYPE:     {Flags: gc.Pseudo | gc.Skip},
	obj.ATEXT:     {Flags: gc.Pseudo},
	obj.AFUNCDATA: {Flags: gc.Pseudo},
	obj.APCDATA:   {Flags: gc.Pseudo},
	obj.AUNDEF:    {Flags: gc.Break},
	obj.AUSEFIELD: {Flags: gc.OK},
	obj.ACHECKNIL: {Flags: gc.LeftRead},
	obj.AVARDEF:   {Flags: gc.Pseudo | gc.RightWrite},
	obj.AVARKILL:  {Flags: gc.Pseudo | gc.RightWrite},
	obj.AVARLIVE:  {Flags: gc.Pseudo | gc.LeftRead},

	// NOP is an internal no-op that also stands
	// for USED and SET annotations, not the Power opcode.
	obj.ANOP:      {Flags: gc.LeftRead | gc.RightWrite},
	sparc64.ARNOP: {Flags: gc.OK},

	// Integer
	sparc64.AADD:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ASUB:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ANEG:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AAND:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AOR:    {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AXOR:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AMULD:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ASDIVD: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AUDIVD: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ASLLD:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ASRLD:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ASRAD:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ASLLW:  {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ASRLW:  {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ASRAW:  {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.ACMP:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead},

	// Floating point.
	sparc64.AFADDD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AFADDS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AFSUBD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AFSUBS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AFNEGD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite},
	sparc64.AFNEGS:  {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite},
	sparc64.AFSQRTD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite},
	sparc64.AFMULD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AFMULS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AFDIVD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AFDIVS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite},
	sparc64.AFCMPD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead},
	sparc64.AFCMPS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead},

	// float -> integer
	sparc64.AFDTOX: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	sparc64.AFSTOX: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	sparc64.AFDTOI: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	sparc64.AFSTOI: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},

	// float -> float
	sparc64.AFSTOD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	sparc64.AFDTOS: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},

	// integer -> float
	sparc64.AFXTOD: {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	sparc64.AFXTOS: {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	sparc64.AFITOD: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	sparc64.AFITOS: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},

	// Moves
	sparc64.AMOVB:  {Flags: gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.AMOVUB: {Flags: gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.AMOVH:  {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.AMOVUH: {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.AMOVW:  {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.AMOVUW: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.ASTW:   {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.AMOVD:  {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Move},
	sparc64.ASTD:   {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Move},
	sparc64.AFMOVS: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.AFMOVD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Move},
	sparc64.ALDSF:  {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	sparc64.ALDDF:  {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Move},

	sparc64.AMOVA:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVN:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVNE:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVE:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVG:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVLE:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVGE:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVL:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVGU:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVLEU: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVCC:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVCS:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVPOS: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVNEG: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVVC:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVVS:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},

	sparc64.AMOVRZ:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVRLEZ: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVRLZ:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVRNZ:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVRGZ:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},
	sparc64.AMOVRGEZ: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite | gc.Move},

	// Jumps
	obj.AJMP:       {Flags: gc.Jump | gc.Break},
	obj.ACALL:      {Flags: gc.Call},
	sparc64.ABRNZ:  {Flags: gc.Cjmp},
	sparc64.ABCCD:  {Flags: gc.Cjmp},
	sparc64.ABCCW:  {Flags: gc.Cjmp},
	sparc64.ABCSD:  {Flags: gc.Cjmp},
	sparc64.ABCSW:  {Flags: gc.Cjmp},
	sparc64.ABED:   {Flags: gc.Cjmp},
	sparc64.ABEW:   {Flags: gc.Cjmp},
	sparc64.ABGD:   {Flags: gc.Cjmp},
	sparc64.ABGED:  {Flags: gc.Cjmp},
	sparc64.ABGEW:  {Flags: gc.Cjmp},
	sparc64.ABGUD:  {Flags: gc.Cjmp},
	sparc64.ABGUW:  {Flags: gc.Cjmp},
	sparc64.ABGW:   {Flags: gc.Cjmp},
	sparc64.ABLD:   {Flags: gc.Cjmp},
	sparc64.ABLED:  {Flags: gc.Cjmp},
	sparc64.ABLEUD: {Flags: gc.Cjmp},
	sparc64.ABLEUW: {Flags: gc.Cjmp},
	sparc64.ABLEW:  {Flags: gc.Cjmp},
	sparc64.ABLW:   {Flags: gc.Cjmp},
	sparc64.ABNED:  {Flags: gc.Cjmp},
	sparc64.ABNEW:  {Flags: gc.Cjmp},
	sparc64.AFBE:   {Flags: gc.Cjmp},
	sparc64.AFBG:   {Flags: gc.Cjmp},
	sparc64.AFBGE:  {Flags: gc.Cjmp},
	sparc64.AFBL:   {Flags: gc.Cjmp},
	sparc64.AFBLE:  {Flags: gc.Cjmp},
	sparc64.AFBNE:  {Flags: gc.Cjmp},
	obj.ARET:       {Flags: gc.Break},
	obj.ADUFFZERO:  {Flags: gc.Call},
	obj.ADUFFCOPY:  {Flags: gc.Call},
}

func proginfo(p *obj.Prog) {
	info := &p.Info
	*info = progtable[p.As]
	if info.Flags == 0 {
		gc.Fatalf("proginfo: unknown instruction %v", p)
	}

	if (info.Flags&gc.RegRead != 0) && p.Reg == 0 {
		info.Flags &^= gc.RegRead
		info.Flags |= gc.RightRead /*CanRegRead |*/
	}

	if (p.From.Type == obj.TYPE_MEM || p.From.Type == obj.TYPE_ADDR) && p.From.Reg != 0 {
		info.Regindex |= RtoB(int(p.From.Reg))
		if p.Scond != 0 {
			info.Regset |= RtoB(int(p.From.Reg))
		}
	}

	if (p.To.Type == obj.TYPE_MEM || p.To.Type == obj.TYPE_ADDR) && p.To.Reg != 0 {
		info.Regindex |= RtoB(int(p.To.Reg))
		if p.Scond != 0 {
			info.Regset |= RtoB(int(p.To.Reg))
		}
	}

	if p.From.Type == obj.TYPE_ADDR && p.From.Sym != nil && (info.Flags&gc.LeftRead != 0) {
		info.Flags &^= gc.LeftRead
		info.Flags |= gc.LeftAddr
	}

	if p.As == obj.ADUFFZERO {
		info.Reguse |= RtoB(sparc64.REG_RT1)
		info.Regset |= RtoB(sparc64.REG_RT1)
	}

	if p.As == obj.ADUFFCOPY {
		// TODO(austin) Revisit when duffcopy is implemented
		info.Reguse |= RtoB(sparc64.REG_RT1) | RtoB(sparc64.REG_RT2) | RtoB(sparc64.REG_G5)

		info.Regset |= RtoB(sparc64.REG_RT1) | RtoB(sparc64.REG_RT2)
	}
}
